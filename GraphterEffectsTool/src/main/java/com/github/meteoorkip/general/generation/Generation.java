package com.github.meteoorkip.general.generation;

import com.github.meteoorkip.graafvis.GraafvisCompiler;
import com.github.meteoorkip.graafvis.errors.VisError;
import com.github.meteoorkip.graafvis.warnings.Warning;
import com.github.meteoorkip.graphloader.Importer;
import com.github.meteoorkip.prolog.TuProlog;
import com.github.meteoorkip.solver.SolveResults;
import com.github.meteoorkip.solver.Solver;
import com.github.meteoorkip.svg.SvgDocumentGenerator;
import com.github.meteoorkip.utils.FileUtils;
import it.unibo.tuprolog.core.Clause;
import org.dom4j.Document;
import org.graphstream.graph.Graph;
import org.xml.sax.SAXException;

import java.io.IOException;
import java.nio.file.Path;
import java.util.List;
import java.util.Observable;

/**
 * Generation Object.
 *
 * <P>This is a data object for a generation process.
 * It contains all the methods necessary to advance generation as well as
 * all the data generated during the generation process.
 */

public class Generation extends Observable{

    private final Path scriptFile;
    private final Path graphFile;

    private final GenerationProgress targetProgress;

    private List<Clause> scriptTerms;
    private Graph graph;
    private Solver solver;
    private TuProlog prolog;
    private SolveResults solveResults;
    private Document generatedSVG;
    private Exception exception;
    private final GraafvisCompiler compiler;

    /**
     * Constructor for a normal generation.
     *
     * @param scriptFile The path of where the Graafvis Script is stored
     * @param graphFile The path of where the Abstract Syntax Graph is stored
     *                  See //TODO{@link } which fileformats are suported.
     */
    public Generation(Path scriptFile, Path graphFile){
        this(scriptFile,graphFile, GenerationProgress.GENERATIONFINISHED);
    }

    /**
     * Constructor for a debug generation. The generation becomes a debug generation
     * if the {@code targetProgress} is not {@link GenerationProgress#GENERATIONFINISHED}.
     *
     * @param scriptFile The path of where the Graafvis Script is stored
     * @param graphFile The path of where the Abstract Syntax Graph is stored
     *                  See //TODO{@link } which fileformats are suported.
     * @param targetProgress The {@link GenerationProgress} until which the generation is supposed to
     *                    continue.
     */
    public Generation(Path scriptFile, Path graphFile, GenerationProgress targetProgress){
        this.scriptFile = scriptFile;
        this.graphFile = graphFile;
        this.targetProgress = targetProgress;
        this.compiler = new GraafvisCompiler();
    }

    /**
     * Compiles the Graafvis Script and notifies its observers about its progress.
     * @throws IOException thrown when the script file could not be read from storage
     * @throws GraafvisCompiler.SyntaxException thrown when the script contains a syntax error
     * @throws GraafvisCompiler.CheckerException thrown when the script contains a grammatical error
     */
    public void compileGraafVis() throws IOException, GraafvisCompiler.SyntaxException, GraafvisCompiler.CheckerException {
        /* Get a string representation of the script */
        String script = FileUtils.readFromFile(scriptFile.toFile());
        scriptTerms = compiler.compile(script);
        setChanged();
        notifyObservers(GenerationProgress.GRAAFVISCOMPILED);
    }


    /**
     * Adds the ASCR Library to the Generation
     * @throws IOException Thrown when an the {@link Graph} could not be loaded from disk.
     * @throws SAXException Thrown when the {@link Graph} file contains syntax errors.
     */
    public void loadGraph() throws IOException, SAXException {
        graph = Importer.graphFromFile(graphFile.toFile());
        setChanged();
        notifyObservers(GenerationProgress.GRAPHLOADED);
    }

    /**
     * Initializes the solver and loads the prolog.
     */
    public void loadProlog() {
        solver = new Solver();
        prolog = solver.loadProlog(graph, scriptTerms);
        setChanged();
        notifyObservers(GenerationProgress.PROLOGLOADED);
    }

    /**
     * Solves the system of logical rules, given by {@link Generation#scriptTerms} and {@link Generation#graph},
     * solves the constraints generated by these rules.
     * and notifies its observers abouts its progress.
     * The resulting Visualization Elements are put into {@link Generation#solveResults}
     * @return If a solutions was file
     */
    public boolean solve() {
        solveResults = solver.solve(prolog);
        setChanged();
        if (solveResults.isSucces()) {
            notifyObservers(GenerationProgress.SOLVED);
            return true;
        } else {
            notifyObservers(GenerationProgress.NOSOLUTION);
            return false;
        }
    }

    /**
     * Generates an SVG based upon the Visualization Elements in the {@link Generation#solveResults}
     * and notifies its observers abouts its progress.
     */
    public void generateSVG() {
        generatedSVG = SvgDocumentGenerator.generate(solveResults.getVisMap().values());
        setChanged();
        notifyObservers(GenerationProgress.SVGGENERATED);
    }

    /** Sets the encountered exception and notifies its observers abouts the encountered exception
     * @param exception the encountered exceptions
     * */
    public void setException(Exception exception) {
        this.exception = exception;
        setChanged();
        if (exception instanceof GraafvisCompiler.SyntaxException || exception instanceof GraafvisCompiler.CheckerException) {
            notifyObservers(GenerationProgress.COMPILEERROR);
        } else {
            notifyObservers(GenerationProgress.ERROROCCURED);
        }
    }

    /** Returns if this generation is a debug generation. The generation is a debug generation
     * if the {@link Generation#targetProgress} is not {@link GenerationProgress#GENERATIONFINISHED}.
     * @return if this generation is a debug generation
     * */
    public boolean isDebug(){
        return !targetProgress.equals(GenerationProgress.GENERATIONFINISHED);
    }

    /**
     * @return the {@link GenerationProgress} until which the generation is supposed to continue.
     */
    public GenerationProgress getTargetProgress(){
        return targetProgress;
    }

    /**
     *  the exception encountered during the generation which caused the generation to be block
     * from continueing.
     * @return the encountered exception
     */
    public Exception getException(){
        return exception;
    }

    /**
     * @return the generated SVG
     */
    public Document getGeneratedSVG() {
        return generatedSVG;
    }

    public TuProlog getProlog() {
        return prolog;
    }

    /**
     * @return the map of the generated visualization elements.
     */
    public SolveResults getSolveResults(){
        return solveResults;
    }

    public List<VisError> getErrors() {
        return compiler.getErrors();
    }

    public List<Warning> getWarnings() {
        return compiler.getWarnings();
    }

    public Path getGraphFile() {
        return graphFile;
    }

    public Path getScriptFile() {
        return scriptFile;
    }

    public List<Clause> getScriptTerms() {
        return scriptTerms;
    }

    public Graph getGraph() {
        return graph;
    }

    public Solver getSolver() {
        return solver;
    }

    public GraafvisCompiler getCompiler() {
        return compiler;
    }

    public void abort() {
        setChanged();
        notifyObservers(GenerationProgress.ABORTED);
    }
}
